"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateOrdersfromPattern = generateOrdersfromPattern;
exports.batchOrder = batchOrder;
const web3_js_1 = require("@solana/web3.js");
const manifest_sdk_1 = require("@cks-systems/manifest-sdk");
const OrderType_1 = require("@cks-systems/manifest-sdk/client/ts/src/wrapper/types/OrderType");
/**
 * Generates an array of orders based on the specified pattern
 */
function generateOrdersfromPattern(pattern) {
    const orders = [];
    // Random number of orders if not specified, max of 8
    const numOrders = pattern.numberOfOrders || Math.ceil(Math.random() * 8);
    // Calculate price points
    const prices = [];
    if (pattern.priceRange) {
        const { min, max } = pattern.priceRange;
        if (min && max) {
            // Generate evenly spaced prices
            for (let i = 0; i < numOrders; i++) {
                if (pattern.spacing?.type === "percentage") {
                    const factor = 1 + pattern.spacing.value / 100;
                    prices.push(min * Math.pow(factor, i));
                }
                else {
                    const step = (max - min) / (numOrders - 1);
                    prices.push(min + step * i);
                }
            }
        }
        else if (min) {
            // Generate prices starting from min with specified spacing
            for (let i = 0; i < numOrders; i++) {
                if (pattern.spacing?.type === "percentage") {
                    const factor = 1 + pattern.spacing.value / 100;
                    prices.push(min * Math.pow(factor, i));
                }
                else {
                    prices.push(min + (pattern.spacing?.value || 0.01) * i);
                }
            }
        }
    }
    // Calculate quantities
    let quantities = [];
    if (pattern.totalQuantity) {
        const individualQty = pattern.totalQuantity / numOrders;
        quantities = Array(numOrders).fill(individualQty);
    }
    else if (pattern.individualQuantity) {
        quantities = Array(numOrders).fill(pattern.individualQuantity);
    }
    // Generate orders
    for (let i = 0; i < numOrders; i++) {
        orders.push({
            side: pattern.side,
            price: prices[i],
            quantity: quantities[i],
        });
    }
    return orders;
}
/**
 * Validates that sell orders are not priced below buy orders
 * @param orders Array of order parameters to validate
 * @throws Error if orders are crossed
 */
function validateNoCrossedOrders(orders) {
    // Find lowest sell and highest buy prices
    let lowestSell = Number.MAX_SAFE_INTEGER;
    let highestBuy = 0;
    orders.forEach((order) => {
        if (order.side === "Sell" && order.price < lowestSell) {
            lowestSell = order.price;
        }
        if (order.side === "Buy" && order.price > highestBuy) {
            highestBuy = order.price;
        }
    });
    // Check if orders cross
    if (lowestSell <= highestBuy) {
        throw new Error(`Invalid order prices: Sell order at ${lowestSell} is lower than or equal to Buy order at ${highestBuy}. Orders cannot cross.`);
    }
}
/**
 * Place batch orders using Manifest
 * @param agent SolanaAgentKit instance
 * @param marketId Public key for the manifest market
 * @param quantity Amount to trade in tokens
 * @param side Buy or Sell
 * @param price Price in tokens ie. SOL/USDC
 * @returns Transaction signature
 */
async function batchOrder(agent, marketId, orders) {
    try {
        validateNoCrossedOrders(orders);
        const mfxClient = await manifest_sdk_1.ManifestClient.getClientForMarket(agent.connection, marketId, agent.wallet);
        const placeParams = orders.map((order) => ({
            numBaseTokens: order.quantity,
            tokenPrice: order.price,
            isBid: order.side === "Buy",
            lastValidSlot: 0,
            orderType: OrderType_1.OrderType.Limit,
            clientOrderId: Number(Math.random() * 10000),
        }));
        const batchOrderIx = await mfxClient.batchUpdateIx(placeParams, [], true);
        const signature = await (0, web3_js_1.sendAndConfirmTransaction)(agent.connection, new web3_js_1.Transaction().add(batchOrderIx), [agent.wallet]);
        return signature;
    }
    catch (error) {
        throw new Error(`Batch Order failed: ${error.message}`);
    }
}
//# sourceMappingURL=batch_order.js.map