import { Connection, Keypair, PublicKey } from "@solana/web3.js";
import Decimal from "decimal.js";
import { Config, TokenCheck } from "../types";
import { mintCollectionNFT, closePerpTradeShort, closePerpTradeLong, openPerpTradeShort, openPerpTradeLong, FEE_TIERS } from "../tools";
import { CollectionDeployment, CollectionOptions, GibworkCreateTaskReponse, JupiterTokenData, MintCollectionNFTResponse, PumpfunLaunchResponse, PumpFunTokenOptions } from "../types";
import { BN } from "@coral-xyz/anchor";
/**
 * Main class for interacting with Solana blockchain
 * Provides a unified interface for token operations, NFT management, trading and more
 *
 * @class SolanaAgentKit
 * @property {Connection} connection - Solana RPC connection
 * @property {Keypair} wallet - Wallet keypair for signing transactions
 * @property {PublicKey} wallet_address - Public key of the wallet
 * @property {Config} config - Configuration object
 */
export declare class SolanaAgentKit {
    connection: Connection;
    wallet: Keypair;
    wallet_address: PublicKey;
    config: Config;
    /**
     * @deprecated Using openai_api_key directly in constructor is deprecated.
     * Please use the new constructor with Config object instead:
     * @example
     * const agent = new SolanaAgentKit(privateKey, rpcUrl, {
     *   OPENAI_API_KEY: 'your-key'
     * });
     */
    constructor(private_key: string, rpc_url: string, openai_api_key: string | null);
    constructor(private_key: string, rpc_url: string, config: Config);
    requestFaucetFunds(): Promise<string>;
    deployToken(name: string, uri: string, symbol: string, decimals?: number, initialSupply?: number): Promise<{
        mint: PublicKey;
    }>;
    deployCollection(options: CollectionOptions): Promise<CollectionDeployment>;
    getBalance(token_address?: PublicKey): Promise<number>;
    getBalanceOther(walletAddress: PublicKey, tokenAddress?: PublicKey): Promise<number>;
    mintNFT(collectionMint: PublicKey, metadata: Parameters<typeof mintCollectionNFT>[2], recipient?: PublicKey): Promise<MintCollectionNFTResponse>;
    transfer(to: PublicKey, amount: number, mint?: PublicKey): Promise<string>;
    registerDomain(name: string, spaceKB?: number): Promise<string>;
    resolveSolDomain(domain: string): Promise<PublicKey>;
    getPrimaryDomain(account: PublicKey): Promise<string>;
    trade(outputMint: PublicKey, inputAmount: number, inputMint?: PublicKey, slippageBps?: number): Promise<string>;
    cancelAllOrders(marketId: PublicKey): Promise<string>;
    withdrawAll(marketId: PublicKey): Promise<string>;
    openPerpTradeLong(args: Omit<Parameters<typeof openPerpTradeLong>[0], "agent">): Promise<string>;
    openPerpTradeShort(args: Omit<Parameters<typeof openPerpTradeShort>[0], "agent">): Promise<string>;
    closePerpTradeShort(args: Omit<Parameters<typeof closePerpTradeShort>[0], "agent">): Promise<string>;
    closePerpTradeLong(args: Omit<Parameters<typeof closePerpTradeLong>[0], "agent">): Promise<string>;
    lendAssets(amount: number): Promise<string>;
    getTPS(): Promise<number>;
    getTokenDataByAddress(mint: string): Promise<JupiterTokenData | undefined>;
    getTokenDataByTicker(ticker: string): Promise<JupiterTokenData | undefined>;
    fetchTokenPrice(mint: string): Promise<string>;
    launchPumpFunToken(tokenName: string, tokenTicker: string, description: string, imageUrl: string, options?: PumpFunTokenOptions): Promise<PumpfunLaunchResponse>;
    stake(amount: number): Promise<string>;
    restake(amount: number): Promise<string>;
    sendCompressedAirdrop(mintAddress: string, amount: number, decimals: number, recipients: string[], priorityFeeInLamports: number, shouldLog: boolean): Promise<string[]>;
    orcaClosePosition(positionMintAddress: PublicKey): Promise<string>;
    orcaCreateCLMM(mintDeploy: PublicKey, mintPair: PublicKey, initialPrice: Decimal, feeTier: keyof typeof FEE_TIERS): Promise<string>;
    orcaCreateSingleSidedLiquidityPool(depositTokenAmount: number, depositTokenMint: PublicKey, otherTokenMint: PublicKey, initialPrice: Decimal, maxPrice: Decimal, feeTier: keyof typeof FEE_TIERS): Promise<string>;
    orcaFetchPositions(): Promise<string>;
    orcaOpenCenteredPositionWithLiquidity(whirlpoolAddress: PublicKey, priceOffsetBps: number, inputTokenMint: PublicKey, inputAmount: Decimal): Promise<string>;
    orcaOpenSingleSidedPosition(whirlpoolAddress: PublicKey, distanceFromCurrentPriceBps: number, widthBps: number, inputTokenMint: PublicKey, inputAmount: Decimal): Promise<string>;
    resolveAllDomains(domain: string): Promise<PublicKey | undefined>;
    getOwnedAllDomains(owner: PublicKey): Promise<string[]>;
    getOwnedDomainsForTLD(tld: string): Promise<string[]>;
    getAllDomainsTLDs(): Promise<string[]>;
    getAllRegisteredAllDomains(): Promise<string[]>;
    getMainAllDomainsDomain(owner: PublicKey): Promise<string | null>;
    raydiumCreateAmmV4(marketId: PublicKey, baseAmount: BN, quoteAmount: BN, startTime: BN): Promise<string>;
    raydiumCreateClmm(mint1: PublicKey, mint2: PublicKey, configId: PublicKey, initialPrice: Decimal, startTime: BN): Promise<string>;
    raydiumCreateCpmm(mint1: PublicKey, mint2: PublicKey, configId: PublicKey, mintAAmount: BN, mintBAmount: BN, startTime: BN): Promise<string>;
    openbookCreateMarket(baseMint: PublicKey, quoteMint: PublicKey, lotSize?: number, tickSize?: number): Promise<string[]>;
    manifestCreateMarket(baseMint: PublicKey, quoteMint: PublicKey): Promise<string[]>;
    pythFetchPrice(priceFeedID: string): Promise<string>;
    createGibworkTask(title: string, content: string, requirements: string, tags: string[], tokenMintAddress: string, tokenAmount: number, payer?: string): Promise<GibworkCreateTaskReponse>;
    rockPaperScissors(amount: number, choice: "rock" | "paper" | "scissors"): Promise<string>;
    createTiplink(amount: number, splmintAddress?: PublicKey): Promise<{
        url: string;
        signature: string;
    }>;
    tensorListNFT(nftMint: PublicKey, price: number): Promise<string>;
    tensorCancelListing(nftMint: PublicKey): Promise<string>;
    fetchTokenReportSummary(mint: string): Promise<TokenCheck>;
    fetchTokenDetailedReport(mint: string): Promise<TokenCheck>;
}
//# sourceMappingURL=index.d.ts.map